# Electron 项目打包优化说明

## 问题分析

### 打包结果对比
- **electron-vite-vue**: app.asar = **32.8 MB** (包含大量 node_modules)
- **origin-electron-vite-vue**: app.asar = **83 KB** (几乎不包含 node_modules)

### 根本原因

**关键误区澄清：Vue 不是运行时依赖！**

很多人认为 Vue 是"运行时依赖"，因为浏览器需要 Vue 才能运行应用。但在 Electron + Vite 的构建场景下：

#### Vue 在哪里？

1. **开发环境 (npm run dev)**:
   - Vue 从 `node_modules/vue` 加载
   - Vite 开发服务器实时编译
   
2. **生产环境 (打包后的应用)**:
   - ✅ Vue 已经被 Vite **打包进** `dist/assets/index-xxx.js` 文件中
   - ✅ 打包后的 JS 文件包含了 Vue 的全部运行时代码
   - ❌ 不需要从 `node_modules/vue` 读取任何文件

**证据**：查看打包后的文件
```powershell
# electron-vite-vue 的 renderer JS 文件包含 Vue 代码
dist/assets/index-D4bnD45d.js  # 114 KB，包含 Vue 3.5.25 的完整代码
```

文件开头可以看到：
```javascript
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function cr(e){...}
// ... Vue 的全部运行时代码都在这里
```

### 真正的问题：dependencies vs devDependencies 的区别

在 **Electron 应用打包** 中：

| 依赖类型 | 用途 | electron-builder 行为 |
|---------|------|---------------------|
| `devDependencies` | 开发和构建时使用 | ❌ **不会打包**到 app.asar |
| `dependencies` | 运行时需要的外部模块 | ✅ **会打包**到 app.asar 的 node_modules |

### 哪些应该放在 dependencies？

**只有以下情况才需要放在 dependencies：**

1. **原生模块（Native Modules）**
   - 包含 C++ 二进制文件的模块
   - 例如：`better-sqlite3`, `serialport`, `node-gyp` 构建的模块
   - 原因：Vite 无法打包二进制文件

2. **需要动态 require 的模块**
   - 在运行时通过路径动态加载的模块
   - 例如：`electron-updater`（需要访问文件系统、网络等）

3. **Electron 特定的运行时库**
   - 依赖 Electron 原生 API 的库
   - 例如：`electron-updater`, `electron-store`

### 哪些应该放在 devDependencies？

**所有可以被 Vite 打包的纯 JavaScript/TypeScript 库：**

1. **前端框架和库**
   - ✅ `vue` - 会被打包进 renderer 的 JS 文件
   - ✅ `react`, `svelte` 等其他框架
   - ✅ `vue-router`, `pinia` 等 Vue 生态库

2. **工具库**
   - ✅ `kysely` - SQL 查询构建器，纯 JS 库
   - ✅ `zod` - 类型验证库，纯 JS 库
   - ✅ `lodash`, `dayjs`, `axios` 等

3. **构建工具**
   - ✅ `vite`, `typescript`, `vue-tsc`
   - ✅ `electron-builder`, `@vitejs/plugin-vue`

## 正确的优化方案

### 修改 1: package.json 依赖配置

**将可以被 Vite 打包的库移到 devDependencies：**

```json
{
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.4",
    "electron": "^39.2.7",
    "electron-builder": "^24.13.3",
    "electron-rebuild": "^3.2.9",
    "prettier": "^3.6.2",
    "typescript": "^5.9.0",
    "vite": "^5.1.5",
    "vite-plugin-electron": "^0.28.4",
    "vite-plugin-electron-renderer": "^0.14.5",
    "vue": "^3.4.21",           // ← Vite 会打包
    "vue-tsc": "^2.0.6"
  },
  "dependencies": {
    "better-sqlite3": "^12.5.0",  // ← 原生模块，必须保留
    "electron-updater": "^6.7.3", // ← Electron 运行时库，必须保留
    "kysely": "^0.28.9",          // ← 纯 JS，但在 main process 使用
    "zod": "^4.2.1"               // ← 纯 JS，但在 main/share 使用
  }
}
```

**注意**：`kysely` 和 `zod` 虽然是纯 JS 库，但它们在 **main process** 中使用。根据您的 vite.config.ts：

```typescript
rollupOptions: {
  external: Object.keys('dependencies' in pkg ? pkg.dependencies : {})
}
```

它们被标记为 `external`，所以需要保留在 `dependencies` 中。

### 修改 2: 使用 vite-plugin-electron/simple

```typescript
// 从
import electron from 'vite-plugin-electron'

// 改为
import electron from 'vite-plugin-electron/simple'
```

并调整插件配置（见 vite.config.ts）

### 修改 3: 添加 type 字段

```json
{
  "type": "module"
}
```

## 为什么 origin-electron-vite-vue 只有 80KB？

因为它：
1. ✅ 将 `vue` 放在 devDependencies（Vite 打包进 JS）
2. ✅ 没有其他运行时依赖（没有使用数据库、更新器等）
3. ✅ 只有必要的代码被打包

## 预期优化效果

### 优化前
```
app.asar
├── package.json
├── dist/              (renderer 代码)
├── dist-electron/     (main/preload 代码)
└── node_modules/      ← 32+ MB
    ├── @babel/        (不需要！)
    ├── kysely/        (需要，但可以优化)
    ├── better-sqlite3/ (必需)
    ├── electron-updater/ (必需)
    ├── zod/           (需要，但可以优化)
    └── 其他很多包...
```

### 优化后
```
app.asar
├── package.json
├── dist/              (renderer 代码，包含 Vue)
├── dist-electron/     (main/preload 代码)
└── node_modules/      ← ~5-10 MB
    ├── better-sqlite3/    (必需，约 2-3 MB)
    ├── electron-updater/  (必需，约 2-3 MB)
    ├── kysely/            (约 1 MB)
    └── zod/               (约 100 KB)
```

**预期大小**：app.asar 从 **32.8 MB** 降低到 **5-10 MB**

## 更进一步的优化（可选）

如果您想进一步减小体积，可以考虑：

### 选项 1: 让 Vite 打包 kysely 和 zod

修改 vite.config.ts，移除它们的 external 配置：

```typescript
rollupOptions: {
  // 只保留真正需要的原生模块
  external: ['better-sqlite3', 'electron-updater']
}
```

然后将 `kysely` 和 `zod` 移到 devDependencies。

**优点**：app.asar 更小（约 3-5 MB）
**缺点**：首次加载稍慢（需要解析打包后的代码）

### 选项 2: 使用 asarUnpack

对于必须保留的依赖，可以配置不打包进 asar：

```json5
// electron-builder.json5
{
  "asarUnpack": [
    "**/node_modules/better-sqlite3/**/*"
  ]
}
```

## 执行步骤

1. 备份当前配置
2. 修改 package.json 和 vite.config.ts（已完成）
3. 删除 node_modules 和 lock 文件
4. 重新安装依赖
5. 重新构建并验证

```powershell
# 进入项目目录
cd "d:\WWW\electron\electron-vite-vue"

# 删除旧的依赖
Remove-Item -Recurse -Force node_modules
Remove-Item -Force pnpm-lock.yaml

# 重新安装
pnpm install

# 构建
pnpm run build

# 检查结果
Get-ChildItem -Path "release\28.0.0\win-unpacked\resources\app.asar" | 
  Select-Object Name, @{Name="Size(MB)";Expression={[math]::Round($_.Length/1MB, 2)}}

# 查看 asar 内容
npx asar list "release\28.0.0\win-unpacked\resources\app.asar" | Select-String "node_modules"
```

## 常见误区总结

❌ **误区 1**: "Vue 是运行时依赖，必须放在 dependencies"
✅ **正确**: Vue 会被 Vite 打包进 JS 文件，应该放在 devDependencies

❌ **误区 2**: "所有 import 的包都是运行时依赖"
✅ **正确**: 只有不能被打包的（原生模块、动态加载的）才是运行时依赖

❌ **误区 3**: "dependencies 的包会被 Vite 排除打包"
✅ **正确**: Vite 的 external 配置决定是否打包，但 electron-builder 会收集所有 dependencies

## 判断规则

当添加新依赖时，问自己：

1. **这是原生模块吗？**（包含 .node 文件）
   - 是 → `dependencies`
   - 否 → 继续下一步

2. **运行时需要访问它的文件吗？**（动态 require、读取文件等）
   - 是 → `dependencies`
   - 否 → 继续下一步

3. **它是纯 JavaScript/TypeScript 库吗？**
   - 是 → `devDependencies`（让 Vite 打包）
   - 否 → 具体分析

## 验证方法

打包后验证 Vue 确实不在 node_modules 中：

```powershell
# 列出 asar 中的 node_modules
npx asar list "release\28.0.0\win-unpacked\resources\app.asar" | 
  Select-String "node_modules/vue"

# 应该返回空，说明 Vue 不在 asar 的 node_modules 中

# 验证 Vue 在打包的 JS 中
Select-String -Pattern "@vue/shared" -Path "dist\assets\*.js"

# 应该能找到，说明 Vue 已被打包进 JS 文件
```
